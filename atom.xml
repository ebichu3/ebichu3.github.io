<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ebichu&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/127286bc8e81892d9ae50c2eec0af3ff</icon>
  <subtitle>to be continued...</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://ebichu3.github.io/"/>
  <updated>2019-07-24T05:52:42.993Z</updated>
  <id>https://ebichu3.github.io/</id>
  
  <author>
    <name>ebichu</name>
    <email>731550187@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>由一个SQL问题引发的：WM_CONCAT、LISTAGG的用法</title>
    <link href="https://ebichu3.github.io/2019/07/23/%E4%B8%80%E4%B8%AASQL%E9%97%AE%E9%A2%98%E5%BC%95%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%83%EF%BC%9AWM_CONCAT%E3%80%81LISTAGGRANK%E3%80%81DENSE_RANK%E7%9A%84%E7%94%A8%E6%B3%95/"/>
    <id>https://ebichu3.github.io/2019/07/23/一个SQL问题引发的思考：WM_CONCAT、LISTAGGRANK、DENSE_RANK的用法/</id>
    <published>2019-07-23T12:11:00.000Z</published>
    <updated>2019-07-24T05:52:42.993Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>详细数据如图一，含义为名字为甲乙丙的三人不限次数任意参加python、c++、java考试，得到的分数等级在第三列。</p><p>现需要筛选出只参过一种考试的人名和科目，结果应如图二。在oracle下SQL该如何写？</p><p><img src="/2019/07/23/一个SQL问题引发的思考：WM_CONCAT、LISTAGGRANK、DENSE_RANK的用法/1.png" alt=""></p><p>图一</p><p><img src="/2019/07/23/一个SQL问题引发的思考：WM_CONCAT、LISTAGGRANK、DENSE_RANK的用法/2.png" alt=""></p><p>图二</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> temp_table (<span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">255</span>), course <span class="built_in">varchar</span>(<span class="number">255</span>), score <span class="built_in">varchar</span>(<span class="number">255</span>));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> temp_table <span class="keyword">VALUES</span> (<span class="string">'甲'</span>, <span class="string">'python'</span>, <span class="string">'c'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> temp_table <span class="keyword">VALUES</span> (<span class="string">'甲'</span>, <span class="string">'python'</span>, <span class="string">'b'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> temp_table <span class="keyword">VALUES</span> (<span class="string">'甲'</span>, <span class="string">'python'</span>, <span class="string">'a'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> temp_table <span class="keyword">VALUES</span> (<span class="string">'乙'</span>, <span class="string">'python'</span>, <span class="string">'a'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> temp_table <span class="keyword">VALUES</span> (<span class="string">'乙'</span>, <span class="string">'c++'</span>, <span class="string">'a'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> temp_table <span class="keyword">VALUES</span> (<span class="string">'丙'</span>, <span class="string">'python'</span>, <span class="string">'c'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> temp_table <span class="keyword">VALUES</span> (<span class="string">'丙'</span>, <span class="string">'java'</span>, <span class="string">'c'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> temp_table <span class="keyword">VALUES</span> (<span class="string">'丙'</span>, <span class="string">'java'</span>, <span class="string">'b'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> temp_table <span class="keyword">VALUES</span> (<span class="string">'丙'</span>, <span class="string">'java'</span>, <span class="string">'a'</span>);</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> temp_table;</span><br></pre></td></tr></table></figure><p>思路一：首先在name、course两列做去重处理。然后以name做分组，过滤出统计数量为一的记录。最后在进行关联得到name、course两列。</p><p>A1:最后关联的步骤使用join连接的方式。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line"><span class="keyword">DISTINCT</span> t.name,</span><br><span class="line">tt.course</span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">(<span class="keyword">SELECT</span> </span><br><span class="line"><span class="keyword">name</span></span><br><span class="line"><span class="keyword">FROM</span> (</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> <span class="keyword">name</span>, course </span><br><span class="line"><span class="keyword">FROM</span> TEMP_TABLE</span><br><span class="line">) </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">name</span></span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">count</span>(<span class="number">1</span>) = <span class="number">1</span>) t </span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> TEMP_TABLE tt <span class="keyword">ON</span> t.name = tt.name</span><br></pre></td></tr></table></figure></p><p>A2:感觉A1的方式有点啰嗦，所以最后的步骤使用的嵌套子查询。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">t.name,</span><br><span class="line">(<span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> course <span class="keyword">FROM</span> TEMP_TABLE <span class="keyword">WHERE</span> <span class="keyword">name</span> = t.name) course</span><br><span class="line"><span class="keyword">FROM</span> (</span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line"><span class="keyword">DISTINCT</span> <span class="keyword">name</span>, </span><br><span class="line">course</span><br><span class="line"><span class="keyword">FROM</span> TEMP_TABLE) t</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> t.name</span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">count</span>(<span class="number">1</span>) = <span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>觉得思路一总的来看还是有点啰嗦，故发给小伙伴们讨论更优解。思路二就是来自小伙伴的想法。</p><p>思路二：首先使用函数把name相同的course列以特殊字符拼接在一行中，然后在此基础上过滤出没有特殊字符的记录。</p><p>A3:使用WM_CONCAT函数，可以在函数中直接做去重处理。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line"><span class="keyword">name</span>,</span><br><span class="line">course</span><br><span class="line"><span class="keyword">FROM</span> (</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span>, WM_CONCAT(<span class="keyword">DISTINCT</span> course) course </span><br><span class="line"><span class="keyword">FROM</span> TEMP_TABLE t </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> t.name</span><br><span class="line">) </span><br><span class="line"><span class="keyword">WHERE</span> course <span class="keyword">NOT</span> <span class="keyword">LIKE</span>  <span class="string">'%,%'</span></span><br></pre></td></tr></table></figure></p><p>A4:使用LISTAGG函数，要提前做去重处理再使用函数。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line"><span class="keyword">name</span>,</span><br><span class="line">course</span><br><span class="line"><span class="keyword">FROM</span> (</span><br><span class="line"><span class="keyword">SELECT</span> t.name, <span class="keyword">LISTAGG</span>(t.course, <span class="string">';'</span>) <span class="keyword">WITHIN</span> <span class="keyword">GROUP</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> t.name, t.course) course</span><br><span class="line"><span class="keyword">FROM</span> (</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> <span class="keyword">name</span>, course </span><br><span class="line"><span class="keyword">FROM</span> TEMP_TABLE</span><br><span class="line">) t </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> t.name</span><br><span class="line">) </span><br><span class="line"><span class="keyword">WHERE</span> course <span class="keyword">NOT</span> <span class="keyword">LIKE</span>  <span class="string">'%;%'</span></span><br></pre></td></tr></table></figure></p><h6 id="总结：WM-CONCAT、LISTAGG的用法"><a href="#总结：WM-CONCAT、LISTAGG的用法" class="headerlink" title="总结：WM_CONCAT、LISTAGG的用法"></a>总结：WM_CONCAT、LISTAGG的用法</h6><ul><li>WM_CONCAT不出现在12c中，所以不建议使用这个函数。但是还是列出了它的不同用法。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line"><span class="keyword">name</span>, </span><br><span class="line">WM_CONCAT(course) course </span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">TEMP_TABLE t </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> t.name</span><br></pre></td></tr></table></figure><p><img src="/2019/07/23/一个SQL问题引发的思考：WM_CONCAT、LISTAGGRANK、DENSE_RANK的用法/3.png" alt=""></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line"><span class="keyword">name</span>, </span><br><span class="line">WM_CONCAT(<span class="keyword">DISTINCT</span> course) course </span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">TEMP_TABLE t </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> t.name</span><br></pre></td></tr></table></figure><p><img src="/2019/07/23/一个SQL问题引发的思考：WM_CONCAT、LISTAGGRANK、DENSE_RANK的用法/4.png" alt=""></p><ul><li>LISTAGG在11.2版本之后可以使用。</li></ul><p><img src="/2019/07/23/一个SQL问题引发的思考：WM_CONCAT、LISTAGGRANK、DENSE_RANK的用法/5.png" alt=""></p><p>对于指定的列，<code>LISTAGG</code>对子<code>ORDER</code> <code>BY</code>句中指定的每个组内的数据进行排序，然后连接列的值。</p><ul><li>作为单集聚合函数，<code>LISTAGG</code>对所有行进行操作并返回单个输出行。</li><li>作为一个组集聚合，该函数操作并返回该<code>GROUP</code> <code>BY</code>子句定义的每个组的输出行。</li><li>作为分析函数，<code>LISTAGG</code>根据中的一个或多个表达式将查询结果集划分为组<code>query_partition_clause</code>。</li></ul><p>函数的参数遵循以下规则：</p><ul><li><code>measure_expr</code>可以是任何列。度量列中的空值将被忽略。</li><li><code>delimiter_expr</code>指定是分开测量的值的字符串。该子句是可选的，默认为<code>NULL</code>。</li><li>在<code>order_by_clause</code>决定了被返回连接值的顺序。仅当<code>ORDER</code> <code>BY</code>列列表实现唯一排序时，该功能才是确定性的。</li></ul><p>如果列是<code>RAW</code>类型，返回数据类型是<code>RAW</code>，否则返回值是<code>VARCHAR2</code>类型。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="SQL" scheme="https://ebichu3.github.io/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>WEEK一：数据的描述性统计</title>
    <link href="https://ebichu3.github.io/2019/07/20/WEEK%E4%B8%80%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%9A%84%E6%8F%8F%E8%BF%B0%E6%80%A7%E7%BB%9F%E8%AE%A1/"/>
    <id>https://ebichu3.github.io/2019/07/20/WEEK一：数据的描述性统计/</id>
    <published>2019-07-20T03:11:00.000Z</published>
    <updated>2019-07-23T05:54:27.736Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这周时间比较紧张，加上本身工作不太涉及到数据内容的分析描述，所以文章内容主要是知识点的罗列。基本都是从《面向数据科学家的实用统计学》一书中获得。</p><h5 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h5><p>结构化数据有两种基本类型，即数值型数据和分类数据。包括连续型数据、离散型数据、分类数据（其中包括二进制数据）和有序数据。</p><ul><li><p>连续型数据 数据可在一个区间内取任何值。<br>同义词：区间数据、浮点型数据、数值数据</p></li><li><p>离散型数据 数据只能取整数，例如计数。<br>同义词：整数型数据、计数型数据</p></li><li><p>分类型数据 数据只能从特定集合中取值，表示一系列可能的分类。<br>同义词：枚举数据、列举数据、因子数据、标称数据、多分支数据</p></li><li><p>二元数据 一种特殊的分类数据，数据值只能从两个值中取其一（例如 0 或 1，True 或 False）。<br>同义词：二分数据、逻辑型数据、指示器数据、布尔型数据</p></li><li><p>有序数据 具有明确排序的分类数据。<br>同义词：有序因子数据</p></li></ul><h5 id="位置估计"><a href="#位置估计" class="headerlink" title="位置估计"></a>位置估计</h5><p>变量表示了测量数据或计数数据，一个变量的取值可能会数以千计。探索数据的一个基本步骤，就是获得每个特征（变量）的“典型值”。典型值是对数据最常出现位置的估计， 即数据的集中趋势。</p><ul><li>众数 指数据中出现最频繁的一个或一组数值。</li><li>均值 所有数据值之和除以数值的个数。<br>同义词：平均值</li><li>切尾均值 在数据集剔除一定数量的极值后，再求均值。<br>同义词：截尾均值</li><li>加权均值 各数值乘以相应的权重值，然后加总求和，再除以权重的总和。<br>同义词：加权平均值</li><li>中位数 使得数据集中分别有一半数据位于该值之上和之下。<br>同义词：第 50 百分位数</li><li>加权中位数 使得排序数据集中分别有一半的权重之和位于该值之上和之下。</li><li>稳健 对极值不敏感。<br>同义词：耐抗性</li><li>离群值 与大部分数据值差异很大的数据值。<br>同义词：极值</li></ul><p>均值是一种基本的位置度量，但是对极值（离群值）敏感。其他一些度量更为稳健，例如中位数和切尾均值。</p><h5 id="变异性"><a href="#变异性" class="headerlink" title="变异性"></a>变异性</h5><p>位置只是总结特性的一个维度，另一个维度是变异性（variability），也称离差（dispersion）， 它测量了数据值是紧密聚集的还是发散的。变异性是统计学的一个核心概念，统计学关注 如何测量变异性，如何降低变异性，如何识别真实变异性中的随机性，如何识别真实变异 性的各种来源，以及如何在存在变异性的情况下做出决策。</p><ul><li><p>偏差 位置的观测值与估计值间的直接差异。<br>同义词：误差、残差</p></li><li><p>方差 对于 n 个数据值，方差是对距离均值的偏差平方后求和，再除以 n-1。<br>同义词：均方误差</p></li><li><p>标准偏差 方差的平方根。<br>同义词： L2 范数、欧几里得范数</p></li><li><p>平均绝对偏差 对数据值与均值间偏差的绝对值计算均值。<br>同义词：L1 范数、曼哈顿范数</p></li><li><p>中位数绝对偏差 数据值与中位数间绝对偏差的均值。</p></li><li><p>极差 数据集中最大值和最小值间的差值。</p></li><li><p>顺序统计量 基于从大到小排序的数据值的度量。<br>同义词：秩</p></li><li><p>百分位数 表示一个数据集中，P% 的值小于或等于第 P 百分位数，(100-P)% 的值大于或等 于第 P 百分位数。<br>同义词：四分位数</p></li><li><p>四分位距 第 75 百分位数和第 25 百分位数间的差值。<br>同义词：四分位差</p></li></ul><p>方差和标准偏差是日常最广为使用的变异性统计量。方差和标准偏差都对离群值敏感。更稳健的度量包括偏离均值（百分位数、四分位距）的平均（中位数）绝对偏差。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="DATA SCIENCE" scheme="https://ebichu3.github.io/tags/DATA-SCIENCE/"/>
    
  </entry>
  
  <entry>
    <title>kettle基础教程（二）开始你的第一个kettle例子吧</title>
    <link href="https://ebichu3.github.io/2019/03/10/kettle%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89%E5%BC%80%E5%A7%8B%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAkettle%E4%BE%8B%E5%AD%90%E5%90%A7/"/>
    <id>https://ebichu3.github.io/2019/03/10/kettle基础教程（二）开始你的第一个kettle例子吧/</id>
    <published>2019-03-10T10:11:00.000Z</published>
    <updated>2019-07-02T07:42:28.572Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="简要介绍"><a href="#简要介绍" class="headerlink" title="简要介绍"></a>简要介绍</h2><p>通过上篇文章已经安装好kettle了吧（如果有问题和意见欢迎评论提问交流）。我认为学习一个工具，最好的方式就是直接上手去做，遇到问题解决问题，过程中再通过看官方文档等方式进行知识的补充。接下来我们将通过一系列例子来进行kettle的学习，同时本博客也会陆续提供官方文档的中文翻译和个人解读。</p><p>本文将使用kettle实现一个同构数据从MySQL数据迁移到Oracle数据库的例子，通过这个简单的例子你将会学习到以下几点</p><ul><li>kettle的基本操作</li><li>表输入、表输出等转换组件的用法</li></ul><h2 id="示例过程"><a href="#示例过程" class="headerlink" title="示例过程"></a>示例过程</h2><p>双击运行Spoon.bat文件，出现欢迎界面。点击左上角“新建”按钮，图标如下图所示。</p><p><img src="/2019/03/10/kettle基础教程（二）开始你的第一个kettle例子吧/2.png" alt=""></p><p>你会看到有两种文件可供选择，Kettle可以生成两种文件：作业和转换。</p><ul><li>转换完成数据ETL工作</li><li>作业控制完成整个工作流。</li></ul><p>单击按钮，新建一个转换。从左侧核心对象中的“输入”“输出”中分别找出“表输入”“表输出”组件，鼠标单击拖到右边工作面板。按住shift点击“表输入”，再点击“表输出”就可以把两个组件连起来了。箭头代表数据流向。</p><p><img src="/2019/03/10/kettle基础教程（二）开始你的第一个kettle例子吧/3.png" alt=""></p><p>双击“表输入”，进入组件编辑。<br><img src="/2019/03/10/kettle基础教程（二）开始你的第一个kettle例子吧/4.png" alt=""><br>第一次建立数据库连接需点击新建。SQL就按你的需求写就行，全部写完点击确定即可。<br><img src="/2019/03/10/kettle基础教程（二）开始你的第一个kettle例子吧/5.png" alt=""><br>按实际情况填入，数据表空间和索引表空间不用填，建议点击测试测一下是否连接成功。<br>注意: Oracle数据库连接中数据库名称需填写SID。<br>同样双击“表输出”。<br><img src="/2019/03/10/kettle基础教程（二）开始你的第一个kettle例子吧/6.png" alt=""><br>选择数据库连接，你也可以新建一个。<br>介绍一下各项的含义:<br>目标模式：数据库连接下的其他模式或者说用户。<br>目标表: 输出到哪张表。<br>提交记录数：kettle每多少条输出到表一次。<br>裁剪表: 勾选上就每次输出前都会truncate该表再输出。<br>指定数据库字段：勾选上就要使用下面的数据库字段页签，制定kettle数据流字段和输出表字段的映射关系。<br>全部写完点击确定即可。<br><img src="/2019/03/10/kettle基础教程（二）开始你的第一个kettle例子吧/7.png" alt=""><br>点击图中三角号就可以运行了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>数据库连接中Oracle数据库连接中数据库名称需填写SID，而不是servicename</li><li>建立数据库连接后，会出现在左侧菜单——DB连接中。选中后右键点击“共享”，在之后的使用中就可以不用再填写信息，直接选择该连接即可。</li></ul><p><em>以上。</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="ETL" scheme="https://ebichu3.github.io/tags/ETL/"/>
    
      <category term="kettle" scheme="https://ebichu3.github.io/tags/kettle/"/>
    
  </entry>
  
  <entry>
    <title>kettle基础教程（一）简要介绍与安装部署</title>
    <link href="https://ebichu3.github.io/2019/03/08/kettle%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89%E7%AE%80%E8%A6%81%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2/"/>
    <id>https://ebichu3.github.io/2019/03/08/kettle基础教程（一）简要介绍与安装部署/</id>
    <published>2019-03-08T05:11:00.000Z</published>
    <updated>2019-07-02T06:27:53.889Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="简要介绍"><a href="#简要介绍" class="headerlink" title="简要介绍"></a>简要介绍</h2><p>Pentaho Data Integration（PDI，也称为<em>Kettle</em>）是Pentaho的组件，负责提取，转换和加载（ETL）过程。虽然ETL工具最常用于数据仓库环境，但PDI也可用于其他目的：</p><ul><li>在应用程序或数据库之间迁移数据</li><li>将数据从数据库导出到平面文件</li><li>将数据大量加载到数据库中</li><li>数据清理</li><li>集成应用程序</li></ul><p><em>Kettle</em>易于使用。每个进程都使用图形工具创建，可以在其中指定要执行的操作，而无需编写代码来指示如何执行操作; 因此可以说<em>Kettle</em>是<em>面向元数据的</em>。</p><p><em>Kettle</em>可以用作独立应用程序，也可以用作较大的Pentaho Suite的一部分。作为ETL工具，它是最流行的开源工具。<em>Kettle</em>支持大量输入和输出格式，包括文本文件，数据表以及商业和免费数据库引擎。此外，<em>Kettle</em>的转换功能允许用户在极少数限制的情况下操作数据。</p><h2 id="下载与安装"><a href="#下载与安装" class="headerlink" title="下载与安装"></a>下载与安装</h2><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><blockquote><p><a href="https://sourceforge.net/projects/pentaho/" target="_blank" rel="noopener">https://sourceforge.net/projects/pentaho/</a><br>我下载的是pdi-ce-7.0.0.0-25，所以示例都是根据此版本。</p><p><a href="https://www.oracle.com/technetwork/java/javase/downloads/index.html" target="_blank" rel="noopener">https://www.oracle.com/technetwork/java/javase/downloads/index.html</a>  </p><p>JDK下载地址</p></blockquote><table><thead><tr><th>PDI Versions</th><th>5.1</th><th>5.2/5.3/5.4</th><th>6.0/6.1</th><th>7.0/7.1/8.0/8.1</th></tr></thead><tbody><tr><td>Java Versions</td><td>7</td><td>6（build targets）/7</td><td>7/8</td><td>8</td></tr></tbody></table><p>Kettle是由Java编写的免安装软件，运行该软件前需安装jdk，请注意版本适应。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><h4 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h4><h5 id="设置Java环境变量"><a href="#设置Java环境变量" class="headerlink" title="设置Java环境变量"></a>设置Java环境变量</h5><p>网上很多教程，本文不再赘述。</p><h5 id="安装kettle"><a href="#安装kettle" class="headerlink" title="安装kettle"></a>安装kettle</h5><p>kettle不需要安装，只需将zip文件解压缩，进入<em>data-integration</em>文件夹，双击运行Spoon.bat文件即可使用kettle图形用户界面。为了方便使用，建议创建Spoon.bat文件桌面快捷方式，图标使用spoon.ico。<br><img src="/2019/03/08/kettle基础教程（一）简要介绍与安装部署/1.png" alt=""></p><p>安装成功出现以下界面</p><p><img src="/2019/03/08/kettle基础教程（一）简要介绍与安装部署/2.png" alt=""></p><h4 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h4><h5 id="安装jdk并设置环境变量"><a href="#安装jdk并设置环境变量" class="headerlink" title="安装jdk并设置环境变量"></a>安装jdk并设置环境变量</h5><p>网上很多教程，本文不再赘述。</p><h5 id="安装kettle-1"><a href="#安装kettle-1" class="headerlink" title="安装kettle"></a>安装kettle</h5><p>创建一个目录，将下载好的kettle解压后放在该文件夹下。</p><pre><code>#mkdir  /root/software/kettle#cp  /root/pdi-ce-7.0.0.0-25.zip  /root/software/kettle#cd   /root/software/kettle#unzip pdi-ce-7.0.0.0-25.zip#cd  data-integration #ll  *.sh#chmod  +x  *.sh  //赋予.sh结尾的文件必须拥有执行权限</code></pre><p>测试安装是否成功</p><p>在kettle的data-integration目录中执行kitchen.sh文件。</p><pre><code>#./kitchen.sh //执行作业#./pan.sh //执行转换</code></pre><p>安装成功出现帮助信息界面</p><p><img src="/2019/03/08/kettle基础教程（一）简要介绍与安装部署/3.png" alt=""></p><p><em>以上。</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="ETL" scheme="https://ebichu3.github.io/tags/ETL/"/>
    
      <category term="kettle" scheme="https://ebichu3.github.io/tags/kettle/"/>
    
  </entry>
  
</feed>
